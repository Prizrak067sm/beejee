<?php
    class model_main extends Model
    {
        // --- Константы для направления сортировки. ---
        const VECTOR_UP = 'ASC';   // По возрастанию.
        const VECTOR_DOWN = 'DESC';// По убыванию.
        // ---------------------------------------------

        private $count_row_print = 3;   // Количество записей для вывода.
        private $page = 1;   // Текущая страница.
        private $fRow = 1;   // Первая запись для текущей страницы (если по три записи, то это 1, 4,7,10 и т.д.).
        private $column_sort = 'username';   // Столбец сортировки.
        private $vector_sort = self::VECTOR_UP;   // Направление сортировки.

        // --- Свойство для инициализации количества записей для вывода. (Пока не используется) ---
        function set_count_row_print($count)
        {
            $this->count_row_print = $count;
        }
        // --------------------------------------------------------------

        // --- Свойство для получения  количества записей для вывода. ---
        function get_count_row_print()
        {
            return $this->count_row_print;
        }
        // ---------------------------------------------------------------

        // --- Свойство для инициализации "параметров" сортировки. Устанавливаем только при
        //     получении правильных аргументов. Для столбца аргументдолжен совпадать с одним
        //     из наименований столбцов, а для направления с одним из двух значений - ASC или DESC. ---
        function set_filter($column='username', $vector = self::VECTOR_UP)
        {
            $column=strtolower($column);   // В нижний регистр полученное значение столбца. Так как в таблице все в нижнем.
            $columnsName_in_table = $this->get_columnsName();   // Получаем наименования столбцов. С ними будет сравниваться аргумент столбца.

            // --- Если аргумент с потенциальным значением столбца совпадаетс одним из наименований
            //    имеющихся столбцов, то присваиваем его соответствующей переменной класса. ---
            if (in_array($column, $columnsName_in_table))
            {
                $this->column_sort = $column;
            }
            // ---------------------------------------------------------------------------------

            // --- Если аргумент с потенциальным значением направления сортировки совпадает с одним
            //     из двух возможных, то присваиваем его соответствующей переменной класса. ---
            if ($vector=='ASC' or $vector=='DESC')
            {
                $this->vector_sort = $vector;
            }
            // ------------------------------------------------------------------------------------
        }
        // --- Конец свойства установки сортировки. ------------------------------------------------------

        // --- Свойство для инициализации номера текущей страницы. Необходимо для определения первой записи выборки.
        //     А также номера первой записи на текущей странице. Нужно для определения первой записи на вывод. ---
        function set_page($page)
        {
            $this->page = $page>0 ? $page : 1;   // Проверяем, чтобы было положительное.

            // Инициализируем номер записи из таблицы, которая должна быть первой строкой на текущей странице.
            $this->fRow = $page*$this->count_row_print - ($this->count_row_print-1)-1;
        }
        // --------------------------------------------------------------------------------------------------------

        // --- Свойство. На основе по умолчанию или значениями пользователя инициализированных столбца и
        //     направления сортировки возвращает строку для сортировки, которая будет встроена в строку запроса.
        //     Поскольку могут множество записей могут имень одинаковое значение одного поля (имя, статус и т.д.),
        //     то для однозначности  сортировки при смене направления сортировки, предполагается сортировка
        //     сначала по заданным значениям столбца, затем по ид с тем же направлением. ---
        private function set_ruleSorting()
        {
            $column_sort = &$this->column_sort;
            $vector_sort = &$this->vector_sort;
            return "$column_sort $vector_sort, id $vector_sort";
        }
        // --------------------------------------------------------------------------------------------------------

        // --- Возвращает ассоциативный массив записей таблицы с задачами. ---
        function get_data($page=0)
        {
            $this->problem_book->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);

            // --- Инициализируем номер текущей страницы переданным аргументом. ---
            if ($page!=0)
            {
                $this->set_page($page);
            }
            // ---------------------------------------------------------------------

            $fRow = &$this->fRow;   // Номер первой записи для вывода.
            $cRow = &$this->count_row_print;   // Количество записей на вывод.

            $ruleSort = $this->set_ruleSorting();   // Получаем строку сортировки для встраивания в строку запроса.

            $SQL = "SELECT username, email, task, status, edited FROM tasks ORDER BY $ruleSort LIMIT :fRow, :cRow";
            $stmt = $this->problem_book->prepare($SQL);

            $stmt->execute(array(":fRow" => $fRow, ":cRow" => $cRow));
            $result = $stmt->fetchAll(PDO::FETCH_ASSOC);

            return $result;
        }
        // --- Конец. get_data. -----------------------------------------------------

        // ------------- Возвращает массив ИДов записей, которые выведены. -------------
        function get_all_id()
        {
            $this->problem_book->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);

            $fRow = &$this->fRow;   // Номер первой записи на предполагаемый вывод.
            $cRow = &$this->count_row_print;   // Количество записей на предполагаемый вывод.

            $ruleSort = $this->set_ruleSorting();   // Получаем строку сортировки для встраивания в строку запроса.

            $SQL = "SELECT id FROM tasks ORDER BY $ruleSort LIMIT :fRow, :cRow";
            $stmt = $this->problem_book->prepare($SQL);

            $stmt->execute(array(":fRow" => $fRow, ":cRow" => $cRow));

            $result = $stmt->fetchAll(PDO::FETCH_COLUMN,0);

            return $result;
        }
        // --- Конец. get_all_id. --------------------------------------------------------

        // --- Возвращает количество всех-всех записей таблицы с задачами. ---
        function get_countRow()
        {
            $SQL = "SELECT id FROM tasks";

            $stmt = $this->problem_book->query($SQL);
            $result = $stmt->rowCount();

            return $result;
        }
        // --- Конец. get_countRow. ---------------------------------------------

        // --- Возвращает именя всех-всех столбцов таблицы с задачами. ---
        function get_columnsName()
        {
            $SQL = "SELECT * FROM tasks LIMIT 1";

            $stmt = $this->problem_book->query($SQL);
            $stmt->execute();

            $data = $stmt->fetchAll(PDO::FETCH_ASSOC);
            $columns_name = array_keys( $data[0] );

            return $columns_name;
        }
        // --- Конец. get_columnsName. ------------------------------------
    }
?>